<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CoreoMVP v9 — Sincronização de Áudio</title>
  <style>
    :root {
      --cor-fundo: #111827;
      --cor-fundo-secundaria: #1f2937;
      --cor-fundo-terciaria: #374151;
      --cor-borda: #4b5563;
      --cor-texto: #e5e7eb;
      --cor-destaque: #3b82f6;
      --cor-transicao: #db2777;
      --cor-playhead: #f87171;
      --cor-onda-audio: #5eead4; /* Nova cor para a onda de áudio */
    }
    * { box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background-color: var(--cor-fundo); color: var(--cor-texto); margin: 0; padding: 0; overflow: hidden; height: 100vh; display: flex; flex-direction: column; }
    button { background-color: var(--cor-fundo-terciaria); border: 1px solid var(--cor-borda); color: var(--cor-texto); padding: 8px 12px; border-radius: 6px; cursor: pointer; transition: background-color 0.2s; }
    button:hover { background-color: var(--cor-borda); }
    input[type="file"] { display: none; } /* Esconde os inputs de arquivo */
    .barra-superior { padding: 10px 16px; background-color: var(--cor-fundo-secundaria); border-bottom: 1px solid var(--cor-borda); display: flex; gap: 12px; align-items: center; justify-content: space-between; }
    .left, .right { display: flex; gap: 8px; align-items: center; }
    .container-principal { display: flex; flex: 1; min-height: 0; }
    .barra-lateral { width: 280px; background: var(--cor-fundo-secundaria); border-right: 1px solid var(--cor-borda); padding: 16px; display: flex; flex-direction: column; gap: 8px; }
    .palco-wrapper { flex: 1; display: flex; flex-direction: column; }
    .palco-controles { padding: 10px; background-color: var(--cor-fundo-secundaria); border-bottom: 1px solid var(--cor-borda); display: flex; gap: 8px; align-items: center; justify-content: space-between; }
    .palco-container { flex: 1; position: relative; background-image: linear-gradient(var(--cor-borda) 1px, transparent 1px), linear-gradient(to right, var(--cor-borda) 1px, transparent 1px); background-size: 40px 40px; overflow: hidden; }
    .linha-do-tempo { background-color: var(--cor-fundo-secundaria); border-top: 1px solid var(--cor-borda); padding: 12px; display: flex; flex-direction: column; gap: 8px; }
    .lista-formacoes { list-style: none; padding: 0; margin: 0; flex: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 6px; }
    .lista-formacoes li { display: grid; grid-template-columns: 1fr auto auto; align-items: center; gap: 8px; padding: 8px; border-radius: 6px; cursor: pointer; border: 1px solid transparent; }
    .lista-formacoes li.ativa { background-color: var(--cor-destaque); color: white; font-weight: 600; }
    .lista-formacoes li:not(.ativa):hover { background-color: var(--cor-fundo-terciaria); }
    .nome-formacao { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .lista-formacoes button.icon { font-size: 12px; padding: 4px 6px; }
    .lista-formacoes input.edit-input { width: 100%; padding: 6px 8px; border-radius: 6px; border: 1px solid var(--cor-borda); background: var(--cor-fundo-terciaria); color: var(--cor-texto); }
    .marcador { position: absolute; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; cursor: grab; user-select: none; box-shadow: 0 4px 6px rgba(0,0,0,0.3); border: 2px solid rgba(0,0,0,0.2); }
    .marcador:active { cursor: grabbing; z-index: 1000; }
    .controles-playback { display: flex; gap: 10px; justify-content: center; align-items: center; }
    .timeline-container { position: relative; height: 60px; border: 1px solid var(--cor-borda); background: #0b1322; border-top: none; border-radius: 0 0 8px 8px; }
    .timeline-blocos { display: flex; height: 100%; width: 100%; align-items: stretch; overflow: hidden; border-radius: 8px; }
    .bloco-formacao { position: relative; display: flex; align-items: center; justify-content: flex-start; padding-left: 10px; height: 100%; background-color: var(--cor-fundo-terciaria); border-right: 1px solid var(--cor-borda); font-size: 13px; cursor: pointer; color: var(--cor-texto); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .bloco-formacao:last-child { border-right: none; }
    .bloco-formacao.ativa { outline: 2px solid var(--cor-destaque); z-index: 2; }
    .sub-bloco-transicao { position: absolute; left: 0; top: 0; height: 100%; background-color: var(--cor-transicao); z-index: 1; opacity: .85; }
    .bloco-formacao span { position: relative; z-index: 2; }
    .playhead { position: absolute; top: -6px; bottom: -6px; left: 0; width: 2px; background-color: var(--cor-playhead); pointer-events: none; z-index: 10; display: none; transform: translateX(0px); }
    .playhead::before { content: ''; position: absolute; top: 0; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent; border-top: 8px solid var(--cor-playhead); }
    .hint { opacity: .8; font-size: 12px; }
    .painel-bailarinos { margin-top: 10px; display: flex; flex-direction: column; gap: 8px; }
    .painel-bailarinos h3 { margin: 0; font-size: 14px; opacity: .95; }
    .busca-input { width: 100%; padding: 8px 10px; border-radius: 6px; border: 1px solid var(--cor-borda); background: var(--cor-fundo-terciaria); color: var(--cor-texto); outline: none; }
    .busca-input:focus { border-color: var(--cor-destaque); }
    .lista-bailarinos { list-style: none; padding: 0; margin: 0; max-height: 28vh; overflow: auto; display: flex; flex-direction: column; gap: 6px; }
    .bailarino-item { display: grid; grid-template-columns: 16px 1fr auto; align-items: center; gap: 8px; padding: 6px 8px; border: 1px solid transparent; border-radius: 6px; cursor: pointer; }
    .bailarino-item:hover { background: var(--cor-fundo-terciaria); }
    .bailarino-item .cor-dot { width: 12px; height: 12px; border-radius: 999px; border: 1px solid rgba(255,255,255,.3); }
    .bailarino-item .nome { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .bailarino-item button.edit { font-size: 12px; padding: 4px 6px; }
    .bailarino-item input.edit-input { width: 100%; padding: 6px 8px; border-radius: 6px; border: 1px solid var(--cor-borda); background: var(--cor-fundo-terciaria); color: var(--cor-texto); }
    .time-ruler { position: relative; height: 28px; background: var(--cor-fundo-secundaria); border: 1px solid var(--cor-borda); border-bottom: none; border-radius: 8px 8px 0 0; }
    .time-ruler .tick { position: absolute; bottom: 0; width: 1px; height: 8px; background: var(--cor-borda); }
    .time-ruler .tick.major { height: 12px; background: var(--cor-texto); }
    .time-ruler .tick-label { position: absolute; bottom: 12px; transform: translateX(-50%); font-size: 11px; opacity: .85; white-space: nowrap; }
    .handle { position: absolute; top: 0; bottom: 0; width: 8px; cursor: ew-resize; opacity: 0; transition: opacity .15s; }
    .bloco-formacao:hover .handle { opacity: 1; }
    .handle-end { right: 0; background: linear-gradient(to left, rgba(255,255,255,.15), rgba(255,255,255,0)); }
    .sub-bloco-transicao .handle-split { position: absolute; right: 0; top: 0; bottom: 0; width: 8px; cursor: ew-resize; background: linear-gradient(to left, rgba(219,39,119,.45), rgba(219,39,119,0)); }
    .audio-track { position: relative; height: 46px; background: #0a1222; border: 1px solid var(--cor-borda); border-top: none; border-radius: 0 0 8px 8px; display: block; cursor: pointer; }
    .audio-track canvas { width: 100%; height: 100%; display: block; }
    /* Timeline com scroll horizontal */
.timeline-container { overflow-x: auto; overflow-y: hidden; }

/* A régua acompanha o scroll, mas sem mostrar outra barra de rolagem */
.time-ruler { overflow-x: auto; scrollbar-width: none; }
.time-ruler::-webkit-scrollbar { display: none; }

    
  </style>
</head>
<body>
  <header class="barra-superior">
    <div class="left">
      <h1 id="titulo-projeto" style="font-size: 1.05em; margin: 0;">Coreografia</h1>
      <button id="btn-exportar">Exportar JSON</button>
      <button id="btn-importar">Importar JSON</button>
      <input id="import-file" type="file" accept="application/json" />
      <button id="btn-carregar-audio">Carregar Áudio</button>
      <input id="audio-file-input" type="file" accept="audio/*" />
    </div>
    <div class="right" id="audio-info">
      <span class="hint">Nenhum áudio carregado</span>
    </div>
  </header>

  <div class="container-principal">
    <aside class="barra-lateral">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <h2 style="margin:0; font-size:16px;">Formações</h2>
        <button id="btn-add-formacao" title="Adicionar formação">+ Add</button>
      </div>
      <ul id="lista-formacoes" class="lista-formacoes"></ul>
      <div class="hint">Dica: clique para ativar, <b>duplo clique para renomear</b>, SHIFT+clique para editar tempos.</div>
      <div class="painel-bailarinos">
        <h3>Bailarinos</h3>
        <input id="busca-bailarinos" class="busca-input" placeholder="Buscar bailarino..." />
        <ul id="lista-bailarinos" class="lista-bailarinos"></ul>
      </div>
    </aside>

    <div class="palco-wrapper">
      <div class="palco-controles">
        <div style="display:flex; gap:8px; align-items:center;">
          <button id="btn-add-bailarino">+ Adicionar Bailarino</button>
          <span class="hint">SHIFT+arrastar para grade. Duplo clique para renomear.</span>
        </div>
        <div class="controles-playback">
          <button id="btn-anterior" title="Anterior (←)">Anterior</button>
          <button id="btn-play-pause" title="Play/Pause (Barra de espaço)">▶ Play</button>
          <button id="btn-proxima" title="Próxima (→)">Próxima</button>
        </div>
      </div>
      <main id="palco" class="palco-container"></main>
    </div>
  </div>

  <footer class="linha-do-tempo">
    <div id="timeline-toolbar" style="display:flex; align-items:center; justify-content: space-between; gap:8px; margin-bottom:6px;">
      <div class="hint">Timeline</div>
      <div id="zoom-controls" style="display:flex; gap:6px; align-items:center;">
        <button id="zoom-out" title="Diminuir zoom">−</button>
        <span id="zoom-value" class="hint">100%</span>
        <button id="zoom-in" title="Aumentar zoom">+</button>
        <button id="zoom-reset" title="Resetar para 100%">⟲</button>
      </div>
    </div>    
    <div id="time-ruler" class="time-ruler"></div>
    <div class="timeline-container" id="timeline-container">
      <div id="timeline-blocos" class="timeline-blocos"></div>
      <div id="playhead" class="playhead"></div>
    </div>
    <div id="audio-track" class="audio-track" title="Clique ou arraste na régua ou aqui para navegar">
      <canvas id="audio-canvas"></canvas>
    </div>
  </footer>

  <script>
    // ======= ESTADO =======
    let db = {
      projeto: { id: 'proj1', titulo: 'Coreografia v8.7' },
      formacoes: [
        { id: 'f1', nome: 'Início', ordem: 1, duracaoSegundos: 2, tempoTransicaoEntradaSegundos: 0, marcadores: [ { id: 'm1', rotulo: 'D1', x: 100, y: 150, cor: '#ef4444' }, { id: 'm2', rotulo: 'D2', x: 200, y: 150, cor: '#3b82f6' } ] },
        { id: 'f2', nome: 'Abertura', ordem: 2, duracaoSegundos: 1.5, tempoTransicaoEntradaSegundos: 1, marcadores: [ { id: 'm1', rotulo: 'D1', x: 150, y: 50, cor: '#ef4444' }, { id: 'm2', rotulo: 'D2', x: 150, y: 250, cor: '#3b82f6' } ] },
        { id: 'f3', nome: 'Final', ordem: 3, duracaoSegundos: 3, tempoTransicaoEntradaSegundos: 2, marcadores: [ { id: 'm1', rotulo: 'D1', x: 400, y: 150, cor: '#ef4444' }, { id: 'm2', rotulo: 'D2', x: 500, y: 150, cor: '#3b82f6' } ] }
      ]
    };
    let formacaoAtivaId = db.formacoes[0]?.id || null;

    // === NOVAS VARIÁVEIS PARA O ÁUDIO ===
    let audioContext = null;
    let audioBuffer = null; // Guarda o áudio decodificado
    let audioSourceNode = null; // Guarda a fonte de som que está tocando
    let waveformData = null; // Guarda os dados para desenhar a onda sonora

    // Playback
    let isPlaying = false; let playbackLoopId = null; let tempoInicioPlayback = 0; let tempoPausadoAcumulado = 0;
    let globalMsAtual = 0;
    // ======= ZOOM / TIME BASE =======
let zoom = 1;
const ZOOM_MIN = 0.25, ZOOM_MAX = 8, ZOOM_STEP = 0.25;
const BASE_PX_PER_SEC = 120; // pixels por segundo no zoom 100%

function getTotalTimelinePx() {
  const totalSeg = Math.max(1, getTimelineTotalSegundos());
  return Math.max(1, Math.floor(totalSeg * BASE_PX_PER_SEC * zoom));
}

function ensurePlayheadInView() {
  const totalPx = getTotalTimelinePx();
  const playheadX = (globalMsAtual / getTimelineTotalMs()) * totalPx;
  const viewStart = timelineContainerEl.scrollLeft;
  const viewEnd   = viewStart + timelineContainerEl.clientWidth;
  if (playheadX < viewStart) {
    timelineContainerEl.scrollLeft = Math.max(0, playheadX - 20);
  } else if (playheadX > viewEnd) {
    timelineContainerEl.scrollLeft = Math.max(0, playheadX - timelineContainerEl.clientWidth / 2);
  }
}

    // Scrub
    let isScrubbing = false;

    // ======= DOM =======
    const tituloProjetoEl = document.getElementById('titulo-projeto');
    const listaFormacoesEl = document.getElementById('lista-formacoes');
    const listaBailarinosEl = document.getElementById('lista-bailarinos');
    const buscaBailarinosInput = document.getElementById('busca-bailarinos');
    const palcoEl = document.getElementById('palco');
    const btnAddFormacao = document.getElementById('btn-add-formacao');
    const btnAddBailarino = document.getElementById('btn-add-bailarino');
    const timelineBlocosEl = document.getElementById('timeline-blocos');
    const timelineContainerEl = document.getElementById('timeline-container');
    const timeRulerEl = document.getElementById('time-ruler');
    const audioTrackEl = document.getElementById('audio-track');
    const audioCanvas = document.getElementById('audio-canvas');
    const playheadEl = document.getElementById('playhead');
    const btnPlayPause = document.getElementById('btn-play-pause');
    const btnAnterior = document.getElementById('btn-anterior');
    const btnProxima = document.getElementById('btn-proxima');
    const btnExportar = document.getElementById('btn-exportar');
    const btnImportar = document.getElementById('btn-importar');
    const importFile = document.getElementById('import-file');
    // === NOVAS REFERÊNCIAS DOM PARA O ÁUDIO ===
    const btnCarregarAudio = document.getElementById('btn-carregar-audio');
    const audioFileInput = document.getElementById('audio-file-input');
    const audioInfoEl = document.getElementById('audio-info');

    const coresBailarinos = ['#ef4444', '#3b82f6', '#22c55e', '#f97316', '#8b5cf6', '#eab308', '#14b8a6'];
    const lerp = (a, b, t) => a + (b - a) * t;
    const btnZoomOut   = document.getElementById('zoom-out');
const btnZoomIn    = document.getElementById('zoom-in');
const btnZoomReset = document.getElementById('zoom-reset');
const zoomValueEl  = document.getElementById('zoom-value');

function setZoom(newZoom) {
  zoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, newZoom));
  if (zoomValueEl) zoomValueEl.textContent = Math.round(zoom * 100) + '%';

  renderizarReguaTempo();
  renderizarLinhaDoTempo();
  renderAtGlobalMs(globalMsAtual); // reposiciona cena/playhead no mesmo tempo
  ensurePlayheadInView();
  renderizarFaixaAudio();
}

btnZoomOut?.addEventListener('click', () => setZoom(zoom - ZOOM_STEP));
btnZoomIn?.addEventListener('click',  () => setZoom(zoom + ZOOM_STEP));
btnZoomReset?.addEventListener('click', () => setZoom(1));


    // ======= RENDER =======
    function renderizarTudo(posicionarPlayhead = false) {
  db.formacoes.sort((a, b) => a.ordem - b.ordem);
  tituloProjetoEl.textContent = db.projeto.titulo;
  renderizarBarraLateral();
  renderizarPalco();
  renderizarLinhaDoTempo();
  renderizarReguaTempo();
  renderizarPainelBailarinos();
  renderizarFaixaAudio();
  if (posicionarPlayhead) posicionarPlayheadNoInicioDaFormacaoAtiva();

  ensurePlayheadInView(); // <- mantém o cursor visível
}
    
    // (As outras funções de renderização como renderizarBarraLateral, renderizarPalco, etc. continuam iguais)

    // ======= NOVA SEÇÃO DE LÓGICA DE ÁUDIO =======
    function inicializarAudioContext() {
      if (audioContext) return;
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      } catch (e) {
        alert("Seu navegador não suporta a Web Audio API, necessária para a funcionalidade de áudio.");
      }
    }

    function carregarArquivoDeAudio(file) {
      if (!file) return;
      inicializarAudioContext();
      audioInfoEl.innerHTML = `<span class="hint">Processando áudio...</span>`;

      const reader = new FileReader();
      reader.onload = (e) => {
        const arrayBuffer = e.target.result;
        audioContext.decodeAudioData(arrayBuffer, (decodedBuffer) => {
          audioBuffer = decodedBuffer;
          audioInfoEl.textContent = `Áudio: ${file.name.substring(0,25)}... (${(audioBuffer.duration).toFixed(1)}s)`;
          
          const totalSegundosFormacoes = db.formacoes.reduce((acc, f) => acc + f.duracaoSegundos + f.tempoTransicaoEntradaSegundos, 0);
          if (audioBuffer.duration > totalSegundosFormacoes) {
            alert(`Aviso: A duração do áudio (${audioBuffer.duration.toFixed(1)}s) é maior que a duração da coreografia (${totalSegundosFormacoes.toFixed(1)}s). A timeline será estendida para corresponder ao áudio.`);
          }
          
          processarAudioParaVisualizacao();
        }, (error) => {
          audioInfoEl.innerHTML = `<span class="hint">Erro ao carregar áudio</span>`;
          alert(`Não foi possível processar este arquivo de áudio. Erro: ${error.message}`);
        });
      };
      reader.readAsArrayBuffer(file);
    }

    function processarAudioParaVisualizacao() {
      if (!audioBuffer) return;
      const rawData = audioBuffer.getChannelData(0); // Pega dados do canal esquerdo
      const samples = 256; // Quantas "barras" desenhar na onda. Mais barras = mais detalhe.
      const blockSize = Math.floor(rawData.length / samples);
      const filteredData = [];
      for (let i = 0; i < samples; i++) {
        let blockStart = blockSize * i;
        let sum = 0;
        for (let j = 0; j < blockSize; j++) {
          sum += Math.abs(rawData[blockStart + j]); // Soma o valor absoluto dos samples
        }
        filteredData.push(sum / blockSize); // Tira a média
      }
      
      const maxVal = Math.max(...filteredData);
const safeMax = maxVal > 0 ? maxVal : 1;     // evita dividir por 0
const multiplier = 1 / safeMax;
waveformData = filteredData.map(n => n * multiplier);

      
renderizarTudo(true);
// desenha de novo no próximo frame, quando o layout já estabilizou
requestAnimationFrame(renderizarFaixaAudio);renderizarTudo(true); // Re-renderiza tudo para a timeline se ajustar ao novo tamanho do áudio
    }

    function renderizarFaixaAudio() {
  const ctx = audioCanvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;

  // Desenhamos no tamanho da JANELA (viewport), não do conteúdo inteiro
  const wCss = Math.max(1, audioTrackEl.clientWidth);
  const hCss = Math.max(1, audioTrackEl.clientHeight);

  audioCanvas.width  = Math.floor(wCss * dpr);
  audioCanvas.height = Math.floor(hCss * dpr);

  const w = audioCanvas.width, h = audioCanvas.height;

  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = '#0d1730';
  ctx.fillRect(0, 0, w, h);

  if (!waveformData || waveformData.length === 0) {
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.beginPath();
    ctx.moveTo(0, h / 2);
    ctx.lineTo(w, h / 2);
    ctx.stroke();
    return;
  }

  // fatia visível com base no scroll da timeline
  const totalPx = getTotalTimelinePx();
  const viewStartPx = timelineContainerEl.scrollLeft;
  const viewEndPx   = viewStartPx + timelineContainerEl.clientWidth;

  const startP = totalPx > 0 ? viewStartPx / totalPx : 0;
  const endP   = totalPx > 0 ? viewEndPx   / totalPx : 1;

  const startIndex = Math.floor(startP * waveformData.length);
  const endIndex   = Math.min(waveformData.length, Math.ceil(endP * waveformData.length));
  const slice = waveformData.slice(startIndex, endIndex);

  // cor via CSS var
  const waveColor = getComputedStyle(document.documentElement)
    .getPropertyValue('--cor-onda-audio')
    .trim() || '#5eead4';
  ctx.fillStyle = waveColor;

  const barWidth = w / Math.max(1, slice.length);
  for (let i = 0; i < slice.length; i++) {
    const value = slice[i];
    const barHeight = value * h;
    const y = (h - barHeight) / 2;
    const x = Math.floor(i * barWidth);
    const bw = Math.max(1, Math.floor(barWidth));
    ctx.fillRect(x, y, bw, barHeight);
  }
}


    // ======= ATUALIZAÇÕES NO PLAYBACK & SCRUB =======
    function getTimelineTotalSegundos() {
      const formacoesTotal = db.formacoes.reduce((acc, f) => acc + f.duracaoSegundos + f.tempoTransicaoEntradaSegundos, 0);
      // Se o áudio for mais longo que a coreografia, a timeline se ajusta a ele.
      if (audioBuffer) {
        return Math.max(formacoesTotal, audioBuffer.duration);
      }
      return formacoesTotal > 0 ? formacoesTotal : 1;
    }

    async function startPlayback() {
  if (isPlaying) return;
  isPlaying = true;
  playheadEl.style.display = 'block';
  btnPlayPause.textContent = '❚❚ Pause';
  ensurePlayheadInView();


  // garante AudioContext ativo (Safari/iOS exigem gesto do usuário)
  if (audioContext && audioContext.state === 'suspended') {
    await audioContext.resume();
  }

  // offset atual é o tempo global renderizado (scrub/teclas/seleção)
  let offsetMs = globalMsAtual;
  if (offsetMs === 0) {
    const idx = db.formacoes.findIndex((f) => f.id === formacaoAtivaId);
    offsetMs = calcularTempoAcumuladoAteFormacao(idx);
    globalMsAtual = offsetMs; // mantém ponteiro
  }

  if (audioBuffer && audioContext) {
    audioSourceNode = audioContext.createBufferSource();
    audioSourceNode.buffer = audioBuffer;
    audioSourceNode.connect(audioContext.destination);
    audioSourceNode.onended = () => stopPlayback(); // encerra junto

    const offsetSec = Math.min(offsetMs / 1000, Math.max(0, audioBuffer.duration - 0.001));
    audioSourceNode.start(0, offsetSec);
    tempoInicioPlayback = audioContext.currentTime - offsetSec;
  } else {
    tempoInicioPlayback = performance.now() - offsetMs;
  }

  playbackLoopId = requestAnimationFrame(cicloDePlayback);
}


function pausePlayback() {
  if (!isPlaying) return;
  isPlaying = false;
  btnPlayPause.textContent = '▶ Play';
  cancelAnimationFrame(playbackLoopId);

  if (audioSourceNode && audioContext) {
    // calcula posição atual via AudioContext
    globalMsAtual = (audioContext.currentTime - tempoInicioPlayback) * 1000;
    try { audioSourceNode.stop(); } catch {}
    audioSourceNode = null;
  } else {
    globalMsAtual = performance.now() - tempoInicioPlayback;
  }
}

function stopPlayback() {
  isPlaying = false;
  btnPlayPause.textContent = '▶ Play';
  cancelAnimationFrame(playbackLoopId);

  if (audioSourceNode) {
    try { audioSourceNode.stop(); } catch {}
    audioSourceNode = null;
  }

  // mantém o playhead visível onde parou
  playheadEl.style.display = 'block';
}


function cicloDePlayback(timestamp) {
  if (!isPlaying) return;

  let tempoDecorridoMs;
  if (audioBuffer && audioContext) {
    tempoDecorridoMs = (audioContext.currentTime - tempoInicioPlayback) * 1000;
  } else {
    if (tempoInicioPlayback === 0) tempoInicioPlayback = timestamp - tempoPausadoAcumulado;
    tempoDecorridoMs = timestamp - tempoInicioPlayback;
  }

  const duracaoTotalMs = getTimelineTotalMs();
  if (tempoDecorridoMs >= duracaoTotalMs) {
    renderAtGlobalMs(duracaoTotalMs);
    ensurePlayheadInView();           // garante playhead visível no fim
    stopPlayback();
    return;
  }

  renderAtGlobalMs(tempoDecorridoMs);
  ensurePlayheadInView();             // <- AUTO-SCROLL: acompanha o marcador

  playbackLoopId = requestAnimationFrame(cicloDePlayback);
}

    
    // ======= EVENTOS =======
    // ... (eventos de clique dos botões de playback, etc., continuam iguais)
    btnCarregarAudio.addEventListener('click', () => audioFileInput.click());
    audioFileInput.addEventListener('change', (e) => carregarArquivoDeAudio(e.target.files[0]));
    
    // --- Inicialização ---


    // ==========================================================
    // == O RESTANTE DO CÓDIGO (CRUD, RENDERIZERS, ETC.) ABAIXO ==
    // ==========================================================
    
    function renderizarBarraLateral() { listaFormacoesEl.innerHTML = ''; db.formacoes.forEach((f) => { const li = document.createElement('li'); li.dataset.id = f.id; if (f.id === formacaoAtivaId) li.classList.add('ativa'); const nome = document.createElement('span'); nome.className = 'nome-formacao'; nome.textContent = `${f.ordem}. ${f.nome}`; const btnEdit = document.createElement('button'); btnEdit.className = 'icon'; btnEdit.textContent = '✎'; btnEdit.title = 'Renomear formação'; btnEdit.addEventListener('click', (e) => { e.stopPropagation(); iniciarEdicaoFormacao(li, f.id, f.nome); }); const btnDel = document.createElement('button'); btnDel.className = 'icon'; btnDel.textContent = '×'; btnDel.title = 'Remover formação'; btnDel.addEventListener('click', (e) => { e.stopPropagation(); removerFormacao(f.id); }); li.appendChild(nome); li.appendChild(btnEdit); li.appendChild(btnDel); li.addEventListener('click', () => mudarFormacaoAtiva(f.id)); li.addEventListener('dblclick', (e) => { e.stopPropagation(); iniciarEdicaoFormacao(li, f.id, f.nome); }); listaFormacoesEl.appendChild(li); }); }
    function iniciarEdicaoFormacao(li, id, nomeAtual) { const nomeSpan = li.querySelector('.nome-formacao'); if (!nomeSpan) return; const input = document.createElement('input'); input.className = 'edit-input'; input.value = nomeAtual; li.replaceChild(input, nomeSpan); input.focus(); input.select(); function confirmar(){ const novo = input.value.trim(); if (novo && novo !== nomeAtual) renomearFormacao(id, novo); else renderizarBarraLateral(); } function cancelar(){ renderizarBarraLateral(); } input.addEventListener('keydown', (e) => { if (e.key === 'Enter') confirmar(); else if (e.key === 'Escape') cancelar(); }); input.addEventListener('blur', confirmar); }
    function renderizarPalco() { palcoEl.innerHTML = ''; const f = db.formacoes.find((x) => x.id === formacaoAtivaId); if (!f) return; f.marcadores.forEach((m) => criarMarcador(m)); }
    function criarMarcador(marcador) { const div = document.createElement('div'); div.className = 'marcador'; div.dataset.id = marcador.id; div.textContent = marcador.rotulo; div.title = marcador.rotulo; div.style.backgroundColor = marcador.cor; div.style.left = `${marcador.x}px`; div.style.top = `${marcador.y}px`; div.addEventListener('dblclick', (e) => { e.preventDefault(); if (isPlaying) return; const novo = prompt('Novo nome do bailarino:', marcador.rotulo); if (novo !== null) { const nome = novo.trim(); if (nome.length) renomearBailarino(marcador.id, nome); } }); div.addEventListener('contextmenu', (e) => { e.preventDefault(); if (isPlaying) return; if (confirm(`Remover o bailarino ${marcador.rotulo}?`)) removerBailarino(marcador.id); }); div.addEventListener('mousedown', (e) => { e.preventDefault(); if (isPlaying) return; const startRect = div.getBoundingClientRect(); const palcoRect = palcoEl.getBoundingClientRect(); const oX = e.clientX - startRect.left; const oY = e.clientY - startRect.top; function onMove(ev) { let x = ev.clientX - palcoRect.left - oX; let y = ev.clientY - palcoRect.top - oY; x = Math.max(0, Math.min(x, palcoRect.width - startRect.width)); y = Math.max(0, Math.min(y, palcoRect.height - startRect.height)); if (ev.shiftKey) { x = Math.round(x / 40) * 40; y = Math.round(y / 40) * 40; } div.style.left = `${x}px`; div.style.top = `${y}px`; marcador.x = x; marcador.y = y; } function onUp() { document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); } document.addEventListener('mousemove', onMove); document.addEventListener('mouseup', onUp); }); palcoEl.appendChild(div); }
    function renderizarLinhaDoTempo() {
  timelineBlocosEl.innerHTML = '';

  const totalSeg = getTimelineTotalSegundos();
  const totalPx  = getTotalTimelinePx();
  timelineBlocosEl.style.width = totalPx + 'px';

  db.formacoes.forEach((f) => {
    const tempoTotalDoBloco = f.duracaoSegundos + f.tempoTransicaoEntradaSegundos;

    const bloco = document.createElement('div');
    bloco.className = 'bloco-formacao';
    if (f.id === formacaoAtivaId) bloco.classList.add('ativa');

    // largura proporcional em PX, não %
    const blocoPx = (tempoTotalDoBloco / totalSeg) * totalPx;
    bloco.style.width = `${blocoPx}px`;

    const texto = document.createElement('span');
    texto.textContent = f.nome;
    bloco.appendChild(texto);

    // interações
    bloco.addEventListener('click', (e) => { if (e.shiftKey) editarTemposFormacao(f); else mudarFormacaoAtiva(f.id); });
    bloco.addEventListener('dblclick', (e) => {
      e.stopPropagation();
      const novo = prompt('Novo nome da formação:', f.nome);
      if (novo !== null) { const n = novo.trim(); if (n) renomearFormacao(f.id, n); }
    });

    // sub-bloco de transição
    let sub = null;
    if (tempoTotalDoBloco > 0) {
      sub = document.createElement('div');
      sub.className = 'sub-bloco-transicao';
      sub.style.width = `${(f.tempoTransicaoEntradaSegundos / tempoTotalDoBloco) * 100}%`;
      sub.title = `Transição: ${f.tempoTransicaoEntradaSegundos}s`;

      const handleSplit = document.createElement('div');
      handleSplit.className = 'handle handle-split';
      handleSplit.title = 'Arraste para ajustar transição';
      handleSplit.addEventListener('mousedown', (e) => {
        e.stopPropagation(); e.preventDefault(); pausePlayback();
        const blocoRect = bloco.getBoundingClientRect();
        const startX = e.clientX;
        const transIni = f.tempoTransicaoEntradaSegundos;
        const totalBloco = f.tempoTransicaoEntradaSegundos + f.duracaoSegundos;
        function onMove(ev) {
          const dx = ev.clientX - startX;
          const secPerPx = totalBloco / (blocoRect.width || 1);
          let novaTrans = transIni + dx * secPerPx;
          const minDur = 0.1;
          novaTrans = Math.max(0, Math.min(totalBloco - minDur, novaTrans));
          sub.style.width = `${(novaTrans / totalBloco) * 100}%`;
          sub.title = `Transição: ${novaTrans.toFixed(2)}s`;
        }
        function onUp(ev) {
          const dx = ev.clientX - startX;
          const secPerPx = totalBloco / (blocoRect.width || 1);
          let novaTrans = transIni + dx * secPerPx;
          const minDur = 0.1;
          novaTrans = Math.max(0, Math.min(totalBloco - minDur, novaTrans));
          f.tempoTransicaoEntradaSegundos = +novaTrans.toFixed(2);
          f.duracaoSegundos = +(totalBloco - novaTrans).toFixed(2);
          document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp);
          renderizarTudo(true);
        }
        document.addEventListener('mousemove', onMove); document.addEventListener('mouseup', onUp);
      });
      sub.appendChild(handleSplit);
      bloco.appendChild(sub);
    }

    // handle de duração (arraste a borda direita)
    const handleEnd = document.createElement('div');
    handleEnd.className = 'handle handle-end';
    handleEnd.title = 'Arraste para ajustar duração';
    handleEnd.addEventListener('mousedown', (e) => {
      e.stopPropagation(); e.preventDefault(); pausePlayback();
      const timelineRect = timelineContainerEl.getBoundingClientRect();
      const startX = e.clientX;
      const durIni = f.duracaoSegundos;
      const transConst = f.tempoTransicaoEntradaSegundos;
      const totalTimelineLocal = getTimelineTotalSegundos();
      function onMove(ev) {
        const dx = ev.clientX - startX;
        const secPerPxContainer = totalTimelineLocal / (timelineRect.width || 1);
        let novaDur = durIni + dx * secPerPxContainer * (timelineContainerEl.clientWidth / getTotalTimelinePx());
        novaDur = Math.max(0.1, novaDur);
        const previewPct = (transConst + novaDur) / (transConst + durIni); // apenas visual
        if (sub) sub.style.width = `${(transConst / (transConst + novaDur)) * 100}%`;
        bloco.title = `Duração: ${novaDur.toFixed(2)}s`;
      }
      function onUp(ev) {
        const dx = ev.clientX - startX;
        const secPerPxContainer = totalTimelineLocal / (timelineRect.width || 1);
        let novaDur = durIni + dx * secPerPxContainer * (timelineContainerEl.clientWidth / getTotalTimelinePx());
        novaDur = Math.max(0.1, novaDur);
        f.duracaoSegundos = +novaDur.toFixed(2);
        document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp);
        renderizarTudo(true);
      }
      document.addEventListener('mousemove', onMove); document.addEventListener('mouseup', onUp);
    });
    bloco.appendChild(handleEnd);

    timelineBlocosEl.appendChild(bloco);
  });
}
    function escolherStep(total, width) { const alvoTicks = Math.max(8, Math.min(12, Math.floor((width || 800) / 120))); const bruto = total / Math.max(1, alvoTicks); const steps = [0.1, 0.2, 0.5, 1, 2, 5, 10, 15, 30, 60, 120, 300, 600]; for (const s of steps) { if (s >= bruto) return s; } return Math.ceil(bruto); }
    function formatarTempo(seg) { if (seg >= 60) { const m = Math.floor(seg / 60); const s = Math.round(seg - m * 60); return `${m}:${String(s).padStart(2,'0')}`; } return seg < 10 ? seg.toFixed(1) + 's' : Math.round(seg) + 's'; }
    function renderizarReguaTempo() {
  if (!timeRulerEl || !timelineContainerEl) return;

  const total = getTimelineTotalSegundos();
  const totalPx = getTotalTimelinePx();

  timeRulerEl.innerHTML = '';
  timeRulerEl.scrollLeft = timelineContainerEl.scrollLeft;

  const content = document.createElement('div');
  content.id = 'time-ruler-content';
  content.style.position = 'relative';
  content.style.height = '100%';
  content.style.width = totalPx + 'px';

  const step = escolherStep(total, totalPx); // decide espaçamento dos ticks
  for (let t = 0; t <= total + 1e-6; t += step) {
    const p = t / total;
    const x = Math.round(p * totalPx);

    const tick = document.createElement('div');
    tick.className = 'tick' + ((Math.round(t / step) % 2 === 0) ? ' major' : '');
    tick.style.left = `${x}px`;

    const label = document.createElement('div');
    label.className = 'tick-label';
    label.style.left = `${x}px`;
    label.textContent = formatarTempo(t);

    content.appendChild(tick);
    content.appendChild(label);
  }

  timeRulerEl.appendChild(content);
}
    function getTimelineTotalMs() { return getTimelineTotalSegundos() * 1000; }
    function getDuracaoTotalMs() { return getTimelineTotalSegundos() * 1000; }
    function renderizarPalcoEmTransicao(origem, destino, progresso) {
  if (!origem || !destino) return;
  palcoEl.innerHTML = '';
  origem.marcadores.forEach((ma) => {
    const mb = destino.marcadores.find((m) => m.id === ma.id);
    if (!mb) return;
    const x = lerp(ma.x, mb.x, progresso);
    const y = lerp(ma.y, mb.y, progresso);
    const div = document.createElement('div');
    div.className = 'marcador';
    div.textContent = ma.rotulo;
    div.style.backgroundColor = ma.cor;
    div.style.left = `${x}px`;
    div.style.top = `${y}px`;
    palcoEl.appendChild(div);
  });
}

function renderizarPalcoEmPausa(formacao) {
  if (!formacao) return;
  if (formacaoAtivaId !== formacao.id) {
    formacaoAtivaId = formacao.id;
    renderizarBarraLateral();
  }
  renderizarPalco();
}

function renderAtGlobalMs(globalMs) {
  globalMsAtual = globalMs; // mantém o ponteiro global atualizado

  const totalTimelineMs = getTimelineTotalMs();
  const progressoTotal = Math.max(0, Math.min(globalMs / totalTimelineMs, 1));

  let acumulado = 0; let fez = false;
  for (let i = 0; i < db.formacoes.length; i++) {
    const f = db.formacoes[i];
    const transMs = f.tempoTransicaoEntradaSegundos * 1000;
    const durMs   = f.duracaoSegundos * 1000;

    if (globalMs < acumulado + transMs) {
      const from = db.formacoes[i - 1];
      const to   = f;
      const t    = transMs === 0 ? 1 : (globalMs - acumulado) / transMs;
      renderizarPalcoEmTransicao(from, to, t);
      fez = true; break;
    }
    acumulado += transMs;

    if (globalMs < acumulado + durMs) {
      renderizarPalcoEmPausa(f);
      fez = true; break;
    }
    acumulado += durMs;
  }

  posicionarPlayheadNoPercentual(progressoTotal);
  if (!fez) {
    const last = db.formacoes[db.formacoes.length - 1];
    if (last) renderizarPalcoEmPausa(last);
  }
}

function posicionarPlayheadNoPercentual(p) {
  const totalPx = getTotalTimelinePx();               // largura total do conteúdo em px
  playheadEl.style.transform = `translateX(${p * totalPx}px)`;
}    function calcularTempoAcumuladoAteFormacao(idx) { let t = 0; for (let i = 0; i < idx; i++) t += db.formacoes[i].tempoTransicaoEntradaSegundos + db.formacoes[i].duracaoSegundos; if (db.formacoes[idx]) t += db.formacoes[idx].tempoTransicaoEntradaSegundos; return t * 1000; }
    function posicionarPlayheadNoInicioDaFormacaoAtiva() {
  const idx = db.formacoes.findIndex((f) => f.id === formacaoAtivaId);
  const acum = calcularTempoAcumuladoAteFormacao(idx);
  const p = acum / getDuracaoTotalMs();
  globalMsAtual = acum;              // mantém ponteiro coerente
  tempoPausadoAcumulado = acum;
  posicionarPlayheadNoPercentual(p);
}
function scrubAt(clientX) {
  const rect = timelineContainerEl.getBoundingClientRect();
  const totalPx = getTotalTimelinePx();

  // posição no conteúdo (considerando scroll)
  const xContent = (clientX - rect.left) + timelineContainerEl.scrollLeft;
  const p = Math.max(0, Math.min(xContent / totalPx, 1));

  const t = p * getTimelineTotalMs();

  if (isPlaying) pausePlayback();
  globalMsAtual = t;
  tempoPausadoAcumulado = t;

  renderAtGlobalMs(t);
  ensurePlayheadInView();
}


    timelineContainerEl.addEventListener('mousedown', (e) => { if (e.button !== 0) return; isScrubbing = true; playheadEl.style.display = 'block'; scrubAt(e.clientX); function onMove(ev){scrubAt(ev.clientX);} function onUp(){ isScrubbing=false; document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp);} document.addEventListener('mousemove', onMove); document.addEventListener('mouseup', onUp); });
    timelineContainerEl.addEventListener('scroll', () => {
  // Rola a régua junto
  timeRulerEl.scrollLeft = timelineContainerEl.scrollLeft;
  // Redesenha só o trecho visível da waveform
  renderizarFaixaAudio();
});

    audioTrackEl.addEventListener('mousedown', (e) => { if (e.button !== 0) return; isScrubbing = true; playheadEl.style.display = 'block'; scrubAt(e.clientX); function onMove(ev){scrubAt(ev.clientX);} function onUp(){ isScrubbing=false; document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp);} document.addEventListener('mousemove', onMove); document.addEventListener('mouseup', onUp); });
    function mudarFormacaoAtiva(id) {
  stopPlayback();
  formacaoAtivaId = id;
  renderizarTudo(true);
  const idx = db.formacoes.findIndex((f) => f.id === formacaoAtivaId);
  const acum = calcularTempoAcumuladoAteFormacao(idx);
  globalMsAtual = acum;
  tempoPausadoAcumulado = acum;
  renderAtGlobalMs(acum);
}
    function editarTemposFormacao(f) { stopPlayback(); const nd = prompt(`Editar DURAÇÃO (s) para "${f.nome}":`, f.duracaoSegundos); if (nd !== null && !isNaN(nd) && nd >= 0) f.duracaoSegundos = parseFloat(nd); const nt = prompt(`Editar TRANSIÇÃO (s) para "${f.nome}":`, f.tempoTransicaoEntradaSegundos); if (nt !== null && !isNaN(nt) && nt >= 0) f.tempoTransicaoEntradaSegundos = parseFloat(nt); renderizarTudo(true); }
    function removerFormacao(id) { const idx = db.formacoes.findIndex((x) => x.id === id); if (idx < 0) return; db.formacoes.splice(idx, 1); if (!db.formacoes.length) { formacaoAtivaId = null; } else if (!db.formacoes.find((f) => f.id === formacaoAtivaId)) { formacaoAtivaId = db.formacoes[0].id; } db.formacoes.forEach((f, i) => (f.ordem = i + 1)); renderizarTudo(true); }
    function adicionarFormacao() { stopPlayback(); const novaOrdem = db.formacoes.length ? Math.max(...db.formacoes.map((f) => f.ordem)) + 1 : 1; const fAtual = db.formacoes.find((f) => f.id === formacaoAtivaId); const nova = { id: `f${Date.now()}`, nome: `Formação ${novaOrdem}`, ordem: novaOrdem, duracaoSegundos: 3, tempoTransicaoEntradaSegundos: 1, marcadores: JSON.parse(JSON.stringify(fAtual?.marcadores || [])) }; db.formacoes.push(nova); mudarFormacaoAtiva(nova.id); }
    function adicionarBailarino() { if (!db.formacoes.length) { alert('Crie uma formação antes.'); return; } stopPlayback(); const total = db.formacoes[0].marcadores.length; const novo = { id: `m${Date.now()}`, rotulo: `D${total + 1}`, x: 50 + Math.random() * 100, y: 50 + Math.random() * 100, cor: coresBailarinos[total % coresBailarinos.length] }; db.formacoes.forEach((f) => f.marcadores.push(JSON.parse(JSON.stringify(novo)))); renderizarTudo(true); }
    function removerBailarino(id) { db.formacoes.forEach((f) => { f.marcadores = f.marcadores.filter((m) => m.id !== id); }); renderizarTudo(true); }
    function renomearBailarino(id, novoRotulo) { db.formacoes.forEach((f) => { const m = f.marcadores.find((x) => x.id === id); if (m) m.rotulo = novoRotulo; }); renderizarTudo(); }
    function renomearFormacao(id, novoNome) { const f = db.formacoes.find((x) => x.id === id); if (!f) return; f.nome = novoNome; renderizarTudo(); }
    function getBailarinosUnicos() { const mapa = new Map(); db.formacoes.forEach((f) => { f.marcadores.forEach((m) => { if (!mapa.has(m.id)) mapa.set(m.id, { id: m.id, rotulo: m.rotulo, cor: m.cor }); }); }); return Array.from(mapa.values()).sort((a, b) => a.rotulo.localeCompare(b.rotulo, 'pt-BR', { sensitivity: 'base' })); }
    function renderizarPainelBailarinos() { const termo = (buscaBailarinosInput?.value || '').trim().toLowerCase(); const todos = getBailarinosUnicos(); const filtrados = termo ? todos.filter((b) => b.rotulo.toLowerCase().includes(termo)) : todos; listaBailarinosEl.innerHTML = ''; filtrados.forEach((b) => { const li = document.createElement('li'); li.className = 'bailarino-item'; li.dataset.id = b.id; const cor = document.createElement('span'); cor.className = 'cor-dot'; cor.style.backgroundColor = b.cor; const nome = document.createElement('span'); nome.className = 'nome'; nome.textContent = b.rotulo; nome.title = b.rotulo; const edit = document.createElement('button'); edit.className = 'edit'; edit.textContent = '✎'; edit.title = 'Renomear'; li.addEventListener('click', (e) => { if (e.target === edit) return; focarBailarinoNoPalco(b.id); }); li.addEventListener('dblclick', () => iniciarEdicaoBailarino(li, b.id, b.rotulo)); edit.addEventListener('click', (e) => { e.stopPropagation(); iniciarEdicaoBailarino(li, b.id, b.rotulo); }); li.appendChild(cor); li.appendChild(nome); li.appendChild(edit); listaBailarinosEl.appendChild(li); }); }
    function focarBailarinoNoPalco(id) { const el = palcoEl.querySelector(`[data-id="${id}"]`); if (!el) return; el.classList.add('selecionado'); setTimeout(() => el.classList.remove('selecionado'), 800); }
    function iniciarEdicaoBailarino(li, id, atual) { const nomeSpan = li.querySelector('.nome'); const input = document.createElement('input'); input.className = 'edit-input'; input.value = atual; li.replaceChild(input, nomeSpan); input.focus(); input.select(); function confirmar(){ const novo = input.value.trim(); if (novo && novo !== atual) renomearBailarino(id, novo); else renderizarPainelBailarinos(); } function cancelar(){ renderizarPainelBailarinos(); } input.addEventListener('keydown', (e) => { if (e.key === 'Enter') confirmar(); else if (e.key === 'Escape') cancelar(); }); input.addEventListener('blur', confirmar); }
    function exportarJSON() { const blob = new Blob([JSON.stringify(db, null, 2)], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `${db.projeto.titulo.replace(/\s+/g,'_').toLowerCase()}_${Date.now()}.json`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); }
    function importarJSON(arquivo) { const reader = new FileReader(); reader.onload = (e) => { try { const data = JSON.parse(e.target.result); if (!data?.formacoes?.length) throw new Error('Formato inválido'); db = data; formacaoAtivaId = db.formacoes[0]?.id || null; renderizarTudo(true); } catch (err) { alert('Falha ao importar JSON: ' + err.message); } }; reader.readAsText(arquivo); }
    btnPlayPause.addEventListener('click', () => (isPlaying ? pausePlayback() : startPlayback()));
    btnAnterior.addEventListener('click', () => { const i = db.formacoes.findIndex((f) => f.id === formacaoAtivaId); if (i > 0) mudarFormacaoAtiva(db.formacoes[i - 1].id); });
    btnProxima.addEventListener('click', () => { const i = db.formacoes.findIndex((f) => f.id === formacaoAtivaId); if (i < db.formacoes.length - 1) mudarFormacaoAtiva(db.formacoes[i + 1].id); });
    btnAddFormacao.addEventListener('click', adicionarFormacao);
    btnAddBailarino.addEventListener('click', adicionarBailarino);
    btnExportar.addEventListener('click', exportarJSON);
    btnImportar.addEventListener('click', () => importFile.click());
    importFile.addEventListener('change', (e) => { const file = e.target.files?.[0]; if (file) importarJSON(file); e.target.value = ''; });
    buscaBailarinosInput?.addEventListener('input', renderizarPainelBailarinos);
    window.addEventListener('resize', () => { renderizarReguaTempo(); renderizarFaixaAudio(); });
    window.addEventListener('keydown', (e) => { if (['INPUT','TEXTAREA'].includes(e.target.tagName)) return; if (e.code === 'Space') { e.preventDefault(); isPlaying ? pausePlayback() : startPlayback(); } else if (e.key === 'ArrowLeft') { const i = db.formacoes.findIndex((f) => f.id === formacaoAtivaId); if (i > 0) mudarFormacaoAtiva(db.formacoes[i - 1].id); } else if (e.key === 'ArrowRight') { const i = db.formacoes.findIndex((f) => f.id === formacaoAtivaId); if (i < db.formacoes.length - 1) mudarFormacaoAtiva(db.formacoes[i + 1].id); } });
    

  </script>
</body>
</html>